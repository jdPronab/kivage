#: import settings settings


<TreeViewNode>:
    canvas.before:
        Color:
            rgba: self.color_selected if self.is_selected else self.odd_color if self.odd else self.even_color
        Rectangle:
            pos: [self.parent.x, self.y] if self.parent else [0, 0]
            size: [self.parent.width, self.height] if self.parent else [1, 1]
        Color:
            rgba: 0, 1, 0, int(not self.is_leaf)
        Rectangle:
            source: 'atlas://data/images/defaulttheme/tree_%s' % ('opened' if self.is_open else 'closed')
            size: self.height / (3. if dp(1) > 1 else 2.), self.height / (3. if dp(1) > 1 else 2.)
            pos: self.x - dp(20), int(self.center_y - (self.height / (3. if dp(1) > 1 else 2.)) * .5)
    canvas.after:
        Color:
            rgba: .5, .5, .5, .2
        Line:
            points: [self.parent.x, self.y, self.parent.right, self.y] if self.parent else []

[FileListEntry@FloatLayout+TreeViewNode]:
    locked: False
    entries: []
    path: ctx.path
    # FIXME: is_selected is actually a read_only treeview property. In this
    # case, however, we're doing this because treeview only has single-selection
    # hardcoded in it. The fix to this would be to update treeview to allow
    # multiple selection.
    is_selected: self.path in ctx.controller().selection

    orientation: 'horizontal'
    size_hint_y: None
    height: '48dp' if dp(1) > 1 else '24dp'
    # Don't allow expansion of the ../ node
    is_leaf: not ctx.isdir or ctx.name.endswith('..' + ctx.sep) or self.locked
    on_touch_down: self.collide_point(*args[1].pos) and ctx.controller().entry_touched(self, args[1])
    on_touch_up: self.collide_point(*args[1].pos) and ctx.controller().entry_released(self, args[1])
    BoxLayout:
        pos: root.pos
        size_hint_x: None
        width: root.width - dp(10)
        Label:
            id: filename
            text_size: self.width, None
            halign: 'left'
            shorten: True
            text: ctx.name
            font_name: ctx.controller().font_name
            color: settings.Primary['text_color']
        Label:
            text_size: self.width, None
            size_hint_x: None
            halign: 'right'
            text: '{}'.format(ctx.get_nice_size())
            font_name: ctx.controller().font_name
            color: settings.Primary['text_color']